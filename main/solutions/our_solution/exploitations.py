
from main.constants import EFC_MAX, EFC_MIN, EFS_MAX, EFS_MIN


def exploitation_grid_around_max_M(results, ground_truth, recall_min, exploitation_budget):
    pass

def exploitation_top_k_M(results, ground_truth, recall_min, exploitation_budget, k=10):
    Ms = sorted(set(M for (M, efC, efS), _ in results))
    targets_for_M = {M: [(EFC_MIN, -1.0), (EFC_MAX, 0.0)] for M in Ms}
    for (M, efC, efS), (tuning_time, recall, qps, *_) in results:
        if recall >= recall_min:
            targets_for_M[M].append((efC, qps))
    # remove M entries with <= 2 elements
    targets_for_M = {
        M: sorted(targets, key=lambda x: x[1], reverse=True)
        for M, targets in targets_for_M.items()
        if len(targets) > 2
    }
    if not targets_for_M:
        print("Exploitation phase: No targets found")
        return
    top_k_M = sorted(targets_for_M.items(), key=lambda x: x[1][0], reverse=True)[:min(k, len(targets_for_M))]
    top_k_M = [M for M, _ in top_k_M]
    top_k_M_efC = {
        M: (targets_for_M[M][1][0], targets_for_M[M][2][0]) for M in top_k_M
    }
    if not top_k_M_efC:
        print("Exploitation phase: No targets found")
        return
    gd = ground_truth
    appended_hp = set()
    print(f"top_k_M_efC: {top_k_M_efC}")
    try:
        for M, efCs in top_k_M_efC.items():
            efC_left, efC_right = min(efCs[0], efCs[1]), max(efCs[0], efCs[1])
            efC_left = max(EFC_MIN, M, efCs[0])
            efC_right = min(EFC_MAX, efCs[1])
            while efC_right - efC_left > 3:
                efC_mid1 = efC_left + (efC_right - efC_left) // 3
                efC_mid2 = efC_right - (efC_right - efC_left) // 3
                print(f"{M} | {efC_left} {efC_mid1} {efC_mid2} {efC_right}")
                efS_mid2 = gd.get_efS(M, efC_mid2, recall_min, efS_min=EFS_MIN, efS_max=EFS_MAX)
                efS_mid1 = gd.get_efS(M, efC_mid1, recall_min, efS_min=EFS_MIN, efS_max=efS_mid2, skip_time=True)
                if gd.tuning_time > exploitation_budget:
                    gd.rollback()
                    raise TimeoutError("tuning time out")
                perf_mid1 = gd.get(M, efC_mid1, efS_mid1)
                perf_mid2 = gd.get(M, efC_mid2, efS_mid2)
                if (M, efC_mid1, efS_mid1) not in appended_hp:
                    results.append(((M, efC_mid1, efS_mid1), (gd.tuning_time, *perf_mid1)))
                    appended_hp.add((M, efC_mid1, efS_mid1))
                if (M, efC_mid2, efS_mid2) not in appended_hp:
                    results.append(((M, efC_mid2, efS_mid2), (gd.tuning_time, *perf_mid2)))
                if perf_mid1[1] <= perf_mid2[1]:
                    efC_left = efC_mid1
                else:
                    efC_right = efC_mid2
    except TimeoutError:
        print("Exploitation time out")
    return results 